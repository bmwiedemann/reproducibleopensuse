#!/usr/bin/perl -w
# for packages that do not build reproducibly, this script tries to find the
# source of indeterminism by reducing various parts of it one by one
# and writing the bitmask to .rb.autoclassify
# see the rbkt script for the meaning of individual bits


use strict;
my $slot=$ENV{slot}||4;

our $nextclean=1;
sub rbk(@)
{
    $ENV{CLEAN}=$nextclean;
    #$nextclean=$_[2]||$_[5]; # FIXME: cleanup after disorderfs hack or when switching rpm versions between main and test repos
    return system("rbkt", @_);
}
sub debugtry(@)
{
    my $result=<STDIN>;chomp($result);
    return $result;
}

sub run(@)
{
    print "trying @_\n";
    rbk(@_);
    #debugtry(@_);
}

sub printclassify(@)
{
    print "classified as @_\n";
    open(my $outfd, ">.rb.autoclassify") or die $!;
    print $outfd "@_\n";
}

sub stupid_bisect($$)
{
    my $min=shift;
    my $max=shift;
    if($#$max != $#$min) {die "need same size"}
    my @cur=@$max;
    for(my $i=$#cur; $i>=0; $i--) {
        next if($min->[$i] == $cur[$i]);
        $cur[$i]=$min->[$i];
        my $res=run(@cur);
        if($res == (1<<8)) {
            $cur[$i]=$max->[$i];
        }
    }
    print "cur: @cur\n";
    printclassify(@cur);
    return @cur;
}

# tweaks that may trigger build failures in some packages:
my @unstable=(0,0,1,1,1,1,1,0,0,0);
my @min=     (0,0,0,0,0,0,0,0,0,0);
my @max=@ARGV;
for(my $i=$#min; $i>=0; $i--) {
    $max[$i]=1 unless defined $max[$i];
}
if(rbk(@max) == (1<<8)) { printclassify(@max, 99); exit 0; }
stupid_bisect(\@min, \@max);

