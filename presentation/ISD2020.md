# Einführung

## Über mich

* Diplominformatiker
* arbeite für SUSE an reproducible builds seit 2016

<!--
Arbeite seit 10 Jahren fuer die Firma SUSE in Nuernberg
und arbeite in den letzten 4 Jahren an reproducible builds fuer unsere Software
-->

# Das Problem

## Warum stempeln wir Eier?

![Eier](img/Eier_bmw.jpg)

<!--
Warum stempeln wir Nummern auf Eier?
Weil wir wissen wollen, wo es herkommt und wie es erzeugt wurde.
-->

## Wo unsere Eier herkommen

![Verschiedene Huehnerhaltung](img/chicken.jpg)

## Gleiches Problem mit Software

![Am r-b Projekt interessierte Organisationen](img/project/project.png)

## Wo unsere Programme herkommen

![Codeflow](img/codeflow.png)

<!--
Entwickler erzeugen git commits, signieren commits und/oder tags. Ist sicher.
Dann irgendwann erzeugen sie tarballs. Sicher falls gpg-signiert
Packagers laden die tarballs in OBS
magic happens on OBS (other distris use developer workstation)
signiertes binär-rpms und repos werden automatisch veröffentlich
Ist sicher auch bei kompromitierten mirror-Servern und http, wegen der Signaturen.

Aber wie wissen wir, dass die binaries keine Hintertüren enthalten, die beim Bauen zugefügt wurden?
-->

## Was sind reproducible builds?

* Zwei mal die Quelldateien bauen liefert die selben Ergebnisse

* * idealerweise bit-identisch (d.h. auch die selben Prüfsummen)

* * schlechter: selber Inhalt nach speziellen Filtern


## Warum reproducible builds?

* Man braucht weniger Vertrauen in die build Maschinen

* Weniger Rechenlast im build-service durch rebuilds

* Kleinere delta-rpms in update repos

* Kann Bandbreite sparen, indem man vor Ort baut

* Man findet andere bugs im Bauvorgang (z.B. [boo#1021353](https://bugzilla.opensuse.org/show_bug.cgi?id=1021353), [boo#1021335](https://bugzilla.opensuse.org/show_bug.cgi?id=1021335), [bash](https://lists.gnu.org/archive/html/bug-bash/2018-07/msg00010.html))

<!--

Viele nützliche Eigenschaften
Man braucht keine Rechenzeit verschwenden, abhängige Pakete zu bauen, wenn sich nichts geändert hat
Es wird sicherer

Aber warum sollte ein Computer nicht deterministisch sein? 2+3 ist doch immer das selbe...

-->

## Typische Probleme

* Zeitstempel, Hostnamen

* rebuild Zähler

* Zufällige Reihenfolge beim Linken von .o Dateien

* CPU-detection beim Bauen

<!--

compile-time CPU detection libatlas3

-->

## Seltenere Probleme

* gcc profile-guided optimizations
* * Wird deterministisch wenn man [immer das selbe macht](https://build.opensuse.org/request/show/499887) im Profiling-Lauf

* `%ghost` files haben teils zufaellige Größe

* [Address Space Layout Randomization (ASLR)](https://github.com/bmwiedemann/theunreproduciblepackage/tree/master/aslr)

* Benchmarking

## Warum macht das noch nicht jeder?

* Performance-Optimierung ist wichtiger

* Details des Bauvorgangs sind wichtiger

* UUIDs per Zufall sind einfacher

* digitale Signaturen enthalten Zeit+Zufall

<!--

## rebuild-test-scripts

* Verfügbar in https://github.com/bmwiedemann/reproducibleopensuse

* Inklusive die Quellen dieser Präsentation https://github.com/bmwiedemann/reproducibleopensuse/blob/master/presentation/reproducible-de.md

## Wie reproduzierbar kann man bauen?

* bit-identisch mit Factory rpm und `osc build --define='%_buildhost reproducible' --define='%clamp_mtime_to_source_date_epoch Y' --define='%use_source_date_epoch_as_buildtime Y'`

-->

## Wo helfen reproducible builds nicht?

* Hintertüren in den Quelldateien
* Puffer-Überläufe und andere Bugs
* Schlechte Kryptografie
* Volkswagen Test-Modus

## Noch Fragen?

