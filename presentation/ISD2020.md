# Einführung

## Über mich

* Diplominformatiker
* arbeite für SUSE an reproducible builds seit 2016

<!--
Arbeite seit 10 Jahren fuer die Firma SUSE in Nuernberg
und arbeite in den letzten 4 Jahren an reproducible builds fuer unsere Software
-->

# Das Problem

## Warum stempeln wir Eier?

![Eier](img/Eier_bmw.jpg)

<!--
Warum stempeln wir Nummern auf Eier?
Weil wir wissen wollen, wo es herkommt und wie es erzeugt wurde.
-->

## Wo unsere Eier herkommen

![Verschiedene Huehnerhaltung](img/chicken.jpg)

## Gleiches Problem mit Software

![Am r-b Projekt interessierte Organisationen](img/project/project.png)

## Wo unsere Programme herkommen

![Codeflow](img/codeflow.png)

<!--
Entwickler erzeugen git commits, signieren commits und/oder tags. Ist sicher.
Dann irgendwann erzeugen sie tarballs. Sicher falls gpg-signiert
Packagers laden die tarballs in OBS
magic happens on OBS (other distris use developer workstation)
signiertes binär-rpms und repos werden automatisch veröffentlich
Ist sicher auch bei kompromitierten mirror-Servern und http, wegen der Signaturen.

Aber wie wissen wir, dass die binaries keine Hintertüren enthalten, die beim Bauen zugefügt wurden?
-->

# Die Lösung

## 

![r-b logo](img/logo-text.png)

## Was sind reproducible builds?

* Zwei mal die Quelldateien bauen liefert die selben Ergebnisse

* * idealerweise bit-identisch (d.h. auch die selben Prüfsummen)

* * schlechter: selber Inhalt nach speziellen Filtern


## Warum reproducible builds?

* Man braucht weniger Vertrauen in die build Maschinen

* Weniger Rechenlast im build-service durch rebuilds

* Kleinere delta-rpms in update repos

* Kann Bandbreite sparen, indem man vor Ort baut

* Man findet andere bugs im Bauvorgang (z.B. [boo#1021353](https://bugzilla.opensuse.org/show_bug.cgi?id=1021353), [boo#1021335](https://bugzilla.opensuse.org/show_bug.cgi?id=1021335), [bash](https://lists.gnu.org/archive/html/bug-bash/2018-07/msg00010.html), [libcbor](https://github.com/PJK/libcbor/pull/72))

<!--

Viele nützliche Eigenschaften
Man braucht keine Rechenzeit verschwenden, abhängige Pakete zu bauen, wenn sich nichts geändert hat
Es wird sicherer

Aber warum sollte ein Computer nicht deterministisch sein? 2+3 ist doch immer das selbe...

-->

## Typische Probleme

* Zeitstempel, Hostnamen

* rebuild Zähler

* Zufällige Reihenfolge beim Linken von .o Dateien

* CPU-detection beim Bauen

<!--

compile-time CPU detection libatlas3

-->

## Seltenere Probleme

* gcc profile-guided optimizations
* * Wird deterministisch wenn man [immer das selbe macht](https://build.opensuse.org/request/show/499887) im Profiling-Lauf

* `%ghost` files haben teils zufaellige Größe

* [Address Space Layout Randomization (ASLR)](https://github.com/bmwiedemann/theunreproduciblepackage/tree/master/aslr)

* Benchmarking

* Alles auf https://github.com/bmwiedemann/theunreproduciblepackage/

## Warum macht das noch nicht jeder?

* Performance-Optimierung ist wichtiger

* Details des Bauvorgangs sind wichtiger

* UUIDs per Zufall sind einfacher

* digitale Signaturen enthalten Zeit+Zufall

<!--

## rebuild-test-scripts

* Verfügbar in https://github.com/bmwiedemann/reproducibleopensuse

* Inklusive die Quellen dieser Präsentation https://github.com/bmwiedemann/reproducibleopensuse/blob/master/presentation/reproducible-de.md

## Wie reproduzierbar kann man bauen?

* bit-identisch mit Factory rpm und `osc build --define='%_buildhost reproducible' --define='%clamp_mtime_to_source_date_epoch Y' --define='%use_source_date_epoch_as_buildtime Y'`

-->

## Wo helfen reproducible builds nicht?

* Hintertüren in den Quelldateien
* Puffer-Überläufe und andere Bugs
* Schlechte Kryptografie
* Volkswagen Test-Modus

## Noch Fragen?

## Lesestoff

* https://www.suse.com/c/?p=42014

* https://en.opensuse.org/openSUSE:Reproducible_Builds

* https://reproducible-builds.org/docs/buy-in/

* https://github.com/bmwiedemann/reproducibleopensuse/blob/presentation/presentation/ISD2020.md


## Bash

```diff
From:	Bernhard M. Wiedemann
Subject:	[PATCH] Use memmove instead of strcpy
Date:	Sat, 7 Jul 2018 07:25:52 +0200

In https://bugzilla.opensuse.org/show_bug.cgi?id=1100488
we found that depending on the build machine, bash-4.4's bash.html would
contain the string Bahh instead of Bash

strcpy can cause corruption when working on overlapping strings
so we use memmove instead that handles this case correctly
---
 support/man2html.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/support/man2html.c b/support/man2html.c
index 6ba50616..f56a8945 100644
--- a/support/man2html.c
+++ b/support/man2html.c
@@ -1992,7 +1992,7 @@ unescape (char *c)
    while (i < l && c[i]) {
        if (c[i] == '\a') {
            if (c[i+1])
-               strcpy(c + i, c + i + 1);       /* should be memmove */
+               memmove(c + i, c + i + 1, strlen(c + i));
        }
```

## foma

https://github.com/mhulden/foma/pull/78

```diff
    Fix crash on 32-bit systems
    
    https://bugzilla.opensuse.org/show_bug.cgi?id=1109949
    
    On 32-bit systems like i586, the sizeof a pointer is 4
    so too little memory was allocated for the following loop

diff --git a/foma/rewrite.c b/foma/rewrite.c
index 8ac140a..f1b2073 100644
--- a/foma/rewrite.c
+++ b/foma/rewrite.c
@@ -103,7 +103,7 @@ struct fsm *fsm_rewrite(struct rewrite_set *all_rules) {
     rb = xxcalloc(1, sizeof(struct rewrite_batch));
     rb->rewrite_set = all_rules;
     rb->num_rules = num_rules;
-    rb->namestrings = xxmalloc(sizeof rb->namestrings * num_rules);
+    rb->namestrings = xxmalloc(sizeof *rb->namestrings * num_rules);
     for (i = 0; i < rb->num_rules; i++) {
        sprintf(rb->namestrings[i], "@#%04i@", i+1);
     }
```

## dpdk

http://patches.dpdk.org/patch/29949/

```diff
--- a/mk/rte.sdkdoc.mk
+++ b/mk/rte.sdkdoc.mk
@@ -93,7 +93,7 @@  $(API_EXAMPLES): api-html-clean
 	$(Q)mkdir -p $(@D)
 	@printf '/**\n' > $(API_EXAMPLES)
 	@printf '@page examples DPDK Example Programs\n\n' >> $(API_EXAMPLES)
-	@find examples -type f -name '*.c' -printf '@example %p\n' >> $(API_EXAMPLES)
+	@find examples -type f -name '*.c' | LC_ALL=C sort | xargs -l echo "@example" >> $(API_EXAMPLES)
 	@printf '*/\n' >> $(API_EXAMPLES)
```

## python sort

https://github.com/skyjake/Doomsday-Engine/pull/18

```diff
    Sort input file list
    so that doomsday.pk3 builds in a reproducible way
    in spite of indeterministic filesystem readdir order.

--- a/doomsday/build/scripts/packres.py
+++ b/doomsday/build/scripts/packres.py
 def process_dir(path, dest_path):
     self.msg("processing %s" % os.path.normpath(path))
-    for file in os.listdir(path):
+    for file in sorted(os.listdir(path)):
         real_file = os.path.join(path, file)
```
